<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Robótica PI – Seguidor de Linha (3 sensores IR + 2x 28BYJ-48)&#10;&#10;Projeto para Arduino UNO com:&#10;- 2 motores 28BYJ-48 via drivers ULN2003 (esquerdo e direito)&#10;- 3 sensores IR agora lidos como ANALÓGICOS (A0, A1, A2)&#10;- Lógica de seguidor de linha com threshold (padrão 500)&#10;&#10;O código principal está em `src/main.cpp`.&#10;&#10;## Pinout (ajuste conforme sua fiação)&#10;- Sensores (saída analógica AO → entradas analógicas do Arduino):&#10;  - Esquerda: A0&#10;  - Centro:  A1&#10;  - Direita: A2&#10;  - Threshold padrão: valores ADC &gt; 500 são tratados como “ATIVO”. Ajuste `SENSOR_THRESHOLD` no código para calibrar.&#10;- Motores (saídas para IN1..IN4 dos ULN2003):&#10;  - Motor ESQUERDO (ULN2003 IN1..IN4): D8, D9, D10, D11&#10;  - Motor DIREITO (ULN2003 IN1..IN4): D5, D6, D7, D12&#10;&#10;A direção “frente” foi ajustada no código (campo `invert` de cada motor). Se precisar inverter novamente, edite `motorLeft.invert` e/ou `motorRight.invert` em `main.cpp`.&#10;&#10;## Log Serial&#10;- O log está ATIVADO (`#define DEBUG 1`).&#10;- Baud: 115200.&#10;- Saída inclui valores ADC (0..1023) e flags interpretadas (L/C/R) com base no threshold.&#10;&#10;Exemplo:&#10;```&#10;adc L=640 C=275 R=860 | act L=1 C=0 R=1 | mode=RIGHT&#10;```&#10;&#10;## Como compilar e carregar&#10;&#10;### Usando PlatformIO (recomendado)&#10;- Passos no VS Code:&#10;  1. Abra a pasta do projeto.&#10;  2. “Build” para compilar (env padrão: `uno`).&#10;  3. “Upload” para carregar.&#10;  4. “Monitor” (115200) para ver os logs.&#10;- Via CLI:&#10;  ```bash&#10;  pio run&#10;  pio run -t upload&#10;  pio device monitor -b 115200&#10;  ```&#10;- Outras placas: use `-e megaatmega1280` ou altere `default_envs` no `platformio.ini`.&#10;&#10;### Usando Arduino IDE&#10;1. Abra `src/main.cpp` (ou copie para um `.ino`).&#10;2. Placa: “Arduino Uno” (ou ajuste para sua placa).&#10;3. Porta: selecione a correta.&#10;4. Verificar → Carregar.&#10;5. Monitor Serial em 115200 baud.&#10;&#10;## Testar no Wokwi (https://wokwi.com)&#10;- `diagram.json` define um UNO vazio. Para simular, adicione no Wokwi sensores com saída analógica (ou potênciometros) ligados a A0/A1/A2 e drivers ULN2003 + 28BYJ-48 aos pinos listados acima.&#10;- Inicie a simulação e abra o Serial (115200) para ver `adc` e `act`.&#10;&#10;## Ajustes de comportamento&#10;- Threshold: `SENSOR_THRESHOLD` (padrão 500). Acima de 500 ativa o lado correspondente.&#10;  - Regras: `adcC &gt; threshold` → reto; `adcL &gt; threshold` (sem `adcR`) → vira esquerda; `adcR &gt; threshold` (sem `adcL`) → vira direita.&#10;- Velocidade: `STEP_DELAY_US_STRAIGHT`, `STEP_DELAY_US_TURN`.&#10;- Passos por loop: `STRAIGHT_STEPS_PER_LOOP`, `TURN_STEPS_PER_LOOP`.&#10;&#10;## Troubleshooting&#10;- Nada no Serial: confira 115200 e porta correta; no Wokwi, abra a aba Serial.&#10;- Direção invertida: ajuste `invert` nos structs `motorLeft`/`motorRight`.&#10;- Oscilações no ADC: use fiação curta, GND comum e, se necessário, média móvel/filtragem (pode ser adicionada).&#10;- Sensores só digitais (sem AO): não use este modo; use a saída DO e leitura digital (ou substitua por sensores com AO).&#10;&#10;## Estrutura&#10;```&#10;platformio.ini&#10;src/main.cpp&#10;diagram.json&#10;include/&#10;lib/&#10;test/&#10;```&#10;&#10;Atualize este README conforme você evoluir a fiação/diagrama.&#10;" />
              <option name="updatedContent" value="# Robótica PI – Seguidor de Linha (3 sensores IR + 2x 28BYJ-48)&#10;&#10;Projeto para Arduino UNO com:&#10;- 2 motores 28BYJ-48 via drivers ULN2003 (esquerdo e direito)&#10;- 3 sensores IR lidos como ANALÓGICOS (A3, A4, A5)&#10;- Lógica de seguidor de linha com threshold (padrão 500) e curvas suaves quando centro+lado ativos&#10;&#10;O código principal está em `src/main.cpp`.&#10;&#10;## Pinout (ajuste conforme sua fiação)&#10;- Sensores (saída analógica AO → entradas analógicas do Arduino):&#10;  - Esquerda: A3&#10;  - Centro:  A4&#10;  - Direita: A5&#10;  - Threshold padrão: valores ADC &gt; 500 são tratados como “ATIVO”. Ajuste `SENSOR_THRESHOLD` no código para calibrar.&#10;- Motores (saídas para IN1..IN4 dos ULN2003):&#10;  - Motor ESQUERDO (ULN2003 IN1..IN4): D8, D9, D10, D11&#10;  - Motor DIREITO (ULN2003 IN1..IN4): D5, D6, D7, D12&#10;&#10;A direção “frente” foi ajustada no código pelo campo `invert` de cada motor. Se ficar invertido no seu hardware, altere `motorLeft.invert` e/ou `motorRight.invert` em `main.cpp`.&#10;&#10;## Regras de movimento&#10;- Centro ativo → seguir reto.&#10;- Lado esquerdo ativo (sem centro/direito) → virar à esquerda (pivô).&#10;- Lado direito ativo (sem centro/esquerdo) → virar à direita (pivô).&#10;- Centro + Esquerda ativos → curva suave à esquerda.&#10;- Centro + Direita ativos → curva suave à direita.&#10;- Nada detectado → seguir reto.&#10;&#10;Curva suave usa menos passos por ciclo e/ou um delay mais alto, resultando em giro menos agressivo.&#10;&#10;## Log Serial&#10;- Log ATIVADO (`#define DEBUG 1`).&#10;- Baud: 115200.&#10;- Saída inclui valores ADC (0..1023) e flags interpretadas (L/C/R) com base no threshold, além do modo atual.&#10;&#10;Exemplo:&#10;```&#10;adc L=640 C=275 R=860 | act L=1 C=0 R=1 | mode=RIGHT&#10;```&#10;&#10;## Como compilar e carregar&#10;&#10;### Usando PlatformIO (recomendado)&#10;- No VS Code:&#10;  1. Abra a pasta do projeto.&#10;  2. Use “Build” para compilar (env padrão: `uno`).&#10;  3. “Upload” para carregar.&#10;  4. “Monitor” (115200) para ver logs.&#10;- Via CLI:&#10;  ```bash&#10;  pio run&#10;  pio run -t upload&#10;  pio device monitor -b 115200&#10;  ```&#10;- Outras placas: altere `default_envs` no `platformio.ini` ou use `-e` na CLI.&#10;&#10;### Usando Arduino IDE&#10;1. Abra `src/main.cpp` (ou copie para um `.ino`).&#10;2. Placa: “Arduino Uno” (ou ajuste para sua placa).&#10;3. Porta: selecione a correta.&#10;4. Verificar → Carregar.&#10;5. Monitor Serial em 115200 baud.&#10;&#10;## Testar no Wokwi (https://wokwi.com)&#10;- Abra o projeto e use o `diagram.json` como base (já contém um UNO).&#10;- Adicione no editor do Wokwi:&#10;  - 3 fontes analógicas (p. ex., potênciometros) nos pinos A3/A4/A5 para simular os sensores IR (AO).&#10;  - 2 drivers ULN2003 + motores 28BYJ-48 conectados aos pinos D8–D11 (esquerdo) e D5–D7, D12 (direito).&#10;- Inicie a simulação e abra o Serial (115200) para ver `adc`/`act`/`mode`.&#10;- Dica: se preferir, pode usar sensores `wokwi-ir-reflect` em modo analógico.&#10;&#10;## Dúvidas comuns de ligação&#10;- GND comum é obrigatório: a bateria pode alimentar tudo, mas o GND da bateria deve estar em comum com o GND do Arduino, dos sensores e dos drivers. Sem GND comum, o Arduino não “enxerga” os sinais.&#10;- Alimentar sensores direto da bateria (VCC/GND) não é problema se o GND for comum ao Arduino e a tensão for compatível (normalmente 5V). Se for maior que 5V, use regulador.&#10;- Saída digital (DO) vs analógica (AO):&#10;  - DO é binário e depende do comparador/potenciômetro do módulo (pode precisar ajustar o trimpot). Em pinos 2/3/4 funciona bem se nível lógico for 0/5V e GND comum.&#10;  - AO entrega um valor proporcional (ADC 0..1023). É o que o código usa em A3/A4/A5.&#10;&#10;## Ajustes de comportamento&#10;- Threshold: `SENSOR_THRESHOLD` (padrão 500). Acima de 500 ativa o lado correspondente.&#10;- Velocidade e “torque aparente” dos 28BYJ-48:&#10;  - Aumente `STEP_DELAY_US_*` para reduzir velocidade e evitar perda de passo (parece mais torque).&#10;  - Diminua para mais velocidade (pode perder torque se muito baixo).&#10;  - Aumente `*_STEPS_PER_LOOP` para ações mais fortes por iteração.&#10;  - Para mais força por passo, você pode trocar a sequência para “full-step de 2 fases” (fica como melhoria futura).&#10;- Direção: ajuste os campos `invert` em `motorLeft`/`motorRight` se precisar.&#10;&#10;## Troubleshooting rápido&#10;- Nada no Serial: confira 115200 e a porta correta; no Wokwi, abra a aba Serial.&#10;- Leituras estranhas: verifique GND comum, ruído na fiação dos sensores e fontes; se oscilar, considere média móvel simples no código.&#10;- Motores tremendo/parados: aumente `STEP_DELAY_US_STRAIGHT/TURN` (ex.: 1500–2000 µs) e confira a ordem dos pinos IN1..IN4.&#10;&#10;## Estrutura&#10;```&#10;platformio.ini&#10;src/main.cpp&#10;diagram.json&#10;include/&#10;lib/&#10;test/&#10;```&#10;&#10;Atualize este README conforme você evoluir a fiação/diagrama." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/diagram.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/diagram.json" />
              <option name="originalContent" value="{&#10;    &quot;version&quot;: 1,&#10;    &quot;author&quot;: &quot;Vinicius&quot;,&#10;    &quot;editor&quot;: &quot;wokwi&quot;,&#10;    &quot;parts&quot;: [ { &quot;type&quot;: &quot;wokwi-arduino-uno&quot;, &quot;id&quot;: &quot;uno&quot;, &quot;top&quot;: 0, &quot;left&quot;: 0, &quot;attrs&quot;: {} } ],&#10;    &quot;connections&quot;: []&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;    &quot;version&quot;: 1,&#10;    &quot;author&quot;: &quot;Vinicius&quot;,&#10;    &quot;editor&quot;: &quot;wokwi&quot;,&#10;    &quot;parts&quot;: [&#10;        { &quot;type&quot;: &quot;wokwi-arduino-uno&quot;, &quot;id&quot;: &quot;uno&quot;, &quot;top&quot;: 0, &quot;left&quot;: 0, &quot;attrs&quot;: {} },&#10;        { &quot;type&quot;: &quot;wokwi-potentiometer&quot;, &quot;id&quot;: &quot;potL&quot;, &quot;top&quot;: 180, &quot;left&quot;: -40, &quot;attrs&quot;: {&quot;value&quot;: 0.5} },&#10;        { &quot;type&quot;: &quot;wokwi-potentiometer&quot;, &quot;id&quot;: &quot;potC&quot;, &quot;top&quot;: 180, &quot;left&quot;: 60,  &quot;attrs&quot;: {&quot;value&quot;: 0.5} },&#10;        { &quot;type&quot;: &quot;wokwi-potentiometer&quot;, &quot;id&quot;: &quot;potR&quot;, &quot;top&quot;: 180, &quot;left&quot;: 160, &quot;attrs&quot;: {&quot;value&quot;: 0.5} }&#10;    ],&#10;    &quot;connections&quot;: [&#10;        [&quot;uno:5V&quot;, &quot;potL:VCC&quot;, &quot;red&quot;, [&quot;v0&quot;]],&#10;        [&quot;uno:GND&quot;, &quot;potL:GND&quot;, &quot;black&quot;, [&quot;v0&quot;]],&#10;        [&quot;potL:SIG&quot;, &quot;uno:A3&quot;, &quot;green&quot;, [&quot;v0&quot;]],&#10;&#10;        [&quot;uno:5V&quot;, &quot;potC:VCC&quot;, &quot;red&quot;, [&quot;v0&quot;]],&#10;        [&quot;uno:GND&quot;, &quot;potC:GND&quot;, &quot;black&quot;, [&quot;v0&quot;]],&#10;        [&quot;potC:SIG&quot;, &quot;uno:A4&quot;, &quot;green&quot;, [&quot;v0&quot;]],&#10;&#10;        [&quot;uno:5V&quot;, &quot;potR:VCC&quot;, &quot;red&quot;, [&quot;v0&quot;]],&#10;        [&quot;uno:GND&quot;, &quot;potR:GND&quot;, &quot;black&quot;, [&quot;v0&quot;]],&#10;        [&quot;potR:SIG&quot;, &quot;uno:A5&quot;, &quot;green&quot;, [&quot;v0&quot;]]&#10;    ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.cpp" />
              <option name="originalContent" value="#include &lt;Arduino.h&gt;&#10;&#10;/*&#10;  Seguidor de linha (preta) com 3 sensores IR e 2x 28BYJ-48 + ULN2003&#10;  Lógica:&#10;    - Esquerda ativa  -&gt; virar à ESQUERDA (pivô)&#10;    - Centro  ativo   -&gt; seguir RETO&#10;    - Direita ativa   -&gt; virar à DIREITA (pivô)&#10;    - Sem leitura     -&gt; seguir RETO&#10;&#10;  Ajustes:&#10;    - Defina os pinos dos sensores e dos motores conforme sua montagem.&#10;    - Para sensores analógicos, ajuste SENSOR_THRESHOLD conforme ambiente.&#10;*/&#10;&#10;#define DEBUG 1  // 1 para imprimir leituras no Serial&#10;&#10;// ----------------------------- Sensores -----------------------------&#10;const uint8_t PIN_S_LEFT   = A3;&#10;const uint8_t PIN_S_CENTER = A4;&#10;const uint8_t PIN_S_RIGHT  = A5;&#10;&#10;// Threshold analógico (0..1023). Ativa acima de 500&#10;const int SENSOR_THRESHOLD = 500;&#10;&#10;// ----------------------------- Motores -----------------------------&#10;// LEFT motor (ULN2003 IN1..IN4)&#10;const uint8_t L_IN1 = 8;&#10;const uint8_t L_IN2 = 9;&#10;const uint8_t L_IN3 = 10;&#10;const uint8_t L_IN4 = 11;&#10;&#10;// RIGHT motor (ULN2003 IN1..IN4)&#10;const uint8_t R_IN1 = 5;&#10;const uint8_t R_IN2 = 6;&#10;const uint8_t R_IN3 = 7;&#10;const uint8_t R_IN4 = 12;&#10;&#10;// Tempo entre meia-etapas (quanto menor, mais rápido).&#10;// Para 28BYJ-48, valores típicos 800–2000 us. Comece com 1200.&#10;const unsigned int STEP_DELAY_US_STRAIGHT = 1200;&#10;const unsigned int STEP_DELAY_US_TURN     = 1000;  // um pouco mais rápido nos giros&#10;&#10;// Quantidade de meia-etapas por iteração (pode refinar o &quot;ganho&quot; da curva)&#10;const uint8_t STRAIGHT_STEPS_PER_LOOP = 1;&#10;const uint8_t TURN_STEPS_PER_LOOP     = 2;&#10;&#10;// ---------------------- Sequência meia-etapa ------------------------&#10;const uint8_t HALFSTEP_SEQ[8][4] = {&#10;  {1,0,0,0},&#10;  {1,1,0,0},&#10;  {0,1,0,0},&#10;  {0,1,1,0},&#10;  {0,0,1,0},&#10;  {0,0,1,1},&#10;  {0,0,0,1},&#10;  {1,0,0,1}&#10;};&#10;&#10;struct Stepper28BYJ {&#10;  uint8_t pins[4];&#10;  int8_t  idx;        // 0..7&#10;  bool    invert;     // inverte o sentido lógico do motor&#10;};&#10;&#10;// Monte aqui conforme sua fiação&#10;// Invertido globalmente para que goStraight() avance para frente&#10;Stepper28BYJ motorLeft  = { {L_IN1, L_IN2, L_IN3, L_IN4}, 0, true };&#10;Stepper28BYJ motorRight = { {R_IN1, R_IN2, R_IN3, R_IN4}, 0, false };&#10;&#10;// ----------------------------- Funções ------------------------------&#10;void writeCoils(const Stepper28BYJ&amp; m, const uint8_t pat[4]) {&#10;  digitalWrite(m.pins[0], pat[0]);&#10;  digitalWrite(m.pins[1], pat[1]);&#10;  digitalWrite(m.pins[2], pat[2]);&#10;  digitalWrite(m.pins[3], pat[3]);&#10;}&#10;&#10;void stepOnce(Stepper28BYJ &amp;m, int dir /* +1 fwd, -1 bwd */) {&#10;  int realDir = m.invert ? -dir : dir;&#10;  m.idx = (m.idx + (realDir &gt; 0 ? 1 : -1) + 8) % 8;&#10;  writeCoils(m, HALFSTEP_SEQ[m.idx]);&#10;}&#10;&#10;void stepBoth(int dirLeft, int dirRight, uint8_t steps, unsigned int delayUs) {&#10;  for (uint8_t i = 0; i &lt; steps; i++) {&#10;    if (dirLeft  != 0) stepOnce(motorLeft,  dirLeft);&#10;    if (dirRight != 0) stepOnce(motorRight, dirRight);&#10;    delayMicroseconds(delayUs);&#10;  }&#10;}&#10;&#10;// Movimentos de alto nível&#10;void goStraight() {&#10;  stepBoth(+1, +1, STRAIGHT_STEPS_PER_LOOP, STEP_DELAY_US_STRAIGHT);&#10;}&#10;&#10;void turnLeftPivot() {&#10;  // Pivô: esquerda para trás, direita para frente&#10;  stepBoth(-1, +1, TURN_STEPS_PER_LOOP, STEP_DELAY_US_TURN);&#10;}&#10;&#10;void turnRightPivot() {&#10;  // Pivô: esquerda para frente, direita para trás&#10;  stepBoth(+1, -1, TURN_STEPS_PER_LOOP, STEP_DELAY_US_TURN);&#10;}&#10;&#10;// ----------------------------- Setup/Loop ---------------------------&#10;enum Mode : uint8_t { MODE_STRAIGHT, MODE_LEFT, MODE_RIGHT, MODE_IDLE };&#10;Mode lastMode = MODE_STRAIGHT;&#10;&#10;void setup() {&#10;  // Sensores analógicos: apenas INPUT (sem pull-up)&#10;  pinMode(PIN_S_LEFT,   INPUT);&#10;  pinMode(PIN_S_CENTER, INPUT);&#10;  pinMode(PIN_S_RIGHT,  INPUT);&#10;&#10;  for (uint8_t p : motorLeft.pins)  pinMode(p, OUTPUT);&#10;  for (uint8_t p : motorRight.pins) pinMode(p, OUTPUT);&#10;&#10;  // Inicializa bobinas desligadas (opcional manter torque: comente as linhas abaixo)&#10;  digitalWrite(L_IN1, LOW); digitalWrite(L_IN2, LOW);&#10;  digitalWrite(L_IN3, LOW); digitalWrite(L_IN4, LOW);&#10;  digitalWrite(R_IN1, LOW); digitalWrite(R_IN2, LOW);&#10;  digitalWrite(R_IN3, LOW); digitalWrite(R_IN4, LOW);&#10;&#10;#if DEBUG&#10;  Serial.begin(115200);&#10;  delay(300);&#10;  Serial.println(F(&quot;Seguidor de linha - 28BYJ-48 + ULN2003&quot;));&#10;  Serial.print(F(&quot;THRESHOLD=&quot;)); Serial.println(SENSOR_THRESHOLD);&#10;#endif&#10;}&#10;&#10;void loop() {&#10;  // Leituras analógicas 0..1023&#10;  int adcL = analogRead(PIN_S_LEFT);&#10;  int adcC = analogRead(PIN_S_CENTER);&#10;  int adcR = analogRead(PIN_S_RIGHT);&#10;&#10;  // Ativação acima do threshold&#10;  bool L = adcL &gt; SENSOR_THRESHOLD;&#10;  bool C = adcC &gt; SENSOR_THRESHOLD;&#10;  bool R = adcR &gt; SENSOR_THRESHOLD;&#10;&#10;  Mode mode;&#10;&#10;  // Prioridade: se centro vê linha, siga reto; senão ajuste para o lado que vê.&#10;  if (C) {&#10;    mode = MODE_STRAIGHT;&#10;  } else if (L &amp;&amp; !R) {&#10;    mode = MODE_LEFT;&#10;  } else if (R &amp;&amp; !L) {&#10;    mode = MODE_RIGHT;&#10;  } else if (L &amp;&amp; R) {&#10;    // Linha larga / cruzamento: tente seguir reto&#10;    mode = MODE_STRAIGHT;&#10;  } else {&#10;    // Nada detectado: seguir reto (pedido do usuário)&#10;    mode = MODE_STRAIGHT;&#10;  }&#10;&#10;#if DEBUG&#10;  static uint32_t t0 = 0;&#10;  uint32_t now = millis();&#10;  if (now - t0 &gt; 100) {&#10;    t0 = now;&#10;    Serial.print(F(&quot;adc L=&quot;)); Serial.print(adcL);&#10;    Serial.print(F(&quot; C=&quot;)); Serial.print(adcC);&#10;    Serial.print(F(&quot; R=&quot;)); Serial.print(adcR);&#10;    Serial.print(F(&quot; | act L=&quot;)); Serial.print(L);&#10;    Serial.print(F(&quot; C=&quot;)); Serial.print(C);&#10;    Serial.print(F(&quot; R=&quot;)); Serial.print(R);&#10;    Serial.print(F(&quot; | mode=&quot;));&#10;    if (mode == MODE_STRAIGHT) Serial.println(F(&quot;STRAIGHT&quot;));&#10;    else if (mode == MODE_LEFT) Serial.println(F(&quot;LEFT&quot;));&#10;    else if (mode == MODE_RIGHT) Serial.println(F(&quot;RIGHT&quot;));&#10;    else Serial.println(F(&quot;IDLE&quot;));&#10;  }&#10;#endif&#10;&#10;  // Executa movimento curto (não bloqueia por muito tempo) e reavalia&#10;  switch (mode) {&#10;    case MODE_STRAIGHT: goStraight(); break;&#10;    case MODE_LEFT:     turnLeftPivot(); break;&#10;    case MODE_RIGHT:    turnRightPivot(); break;&#10;    default:            goStraight(); break; // opção segura: avance devagar&#10;  }&#10;&#10;  lastMode = mode;&#10;}&#10;" />
              <option name="updatedContent" value="#include &lt;Arduino.h&gt;&#10;&#10;/*&#10;  Seguidor de linha (preta) com 3 sensores IR e 2x 28BYJ-48 + ULN2003&#10;  Lógica:&#10;    - Esquerda ativa  -&gt; virar à ESQUERDA (pivô)&#10;    - Centro  ativo   -&gt; seguir RETO&#10;    - Direita ativa   -&gt; virar à DIREITA (pivô)&#10;    - Sem leitura     -&gt; seguir RETO&#10;&#10;  Ajustes:&#10;    - Defina os pinos dos sensores e dos motores conforme sua montagem.&#10;    - Para sensores analógicos, ajuste SENSOR_THRESHOLD conforme ambiente.&#10;*/&#10;&#10;#define DEBUG 1  // 1 para imprimir leituras no Serial&#10;&#10;// ----------------------------- Sensores -----------------------------&#10;const uint8_t PIN_S_LEFT   = A3;&#10;const uint8_t PIN_S_CENTER = A4;&#10;const uint8_t PIN_S_RIGHT  = A5;&#10;&#10;// Threshold analógico (0..1023). Ativa acima de 500&#10;const int SENSOR_THRESHOLD = 500;&#10;&#10;// ----------------------------- Motores -----------------------------&#10;// LEFT motor (ULN2003 IN1..IN4)&#10;const uint8_t L_IN1 = 8;&#10;const uint8_t L_IN2 = 9;&#10;const uint8_t L_IN3 = 10;&#10;const uint8_t L_IN4 = 11;&#10;&#10;// RIGHT motor (ULN2003 IN1..IN4)&#10;const uint8_t R_IN1 = 5;&#10;const uint8_t R_IN2 = 6;&#10;const uint8_t R_IN3 = 7;&#10;const uint8_t R_IN4 = 12;&#10;&#10;// Tempo entre meia-etapas (quanto menor, mais rápido).&#10;// Para 28BYJ-48, valores típicos 800–2000 us. Comece com 1200.&#10;const unsigned int STEP_DELAY_US_STRAIGHT = 1200;&#10;const unsigned int STEP_DELAY_US_TURN     = 1000;  // um pouco mais rápido nos giros&#10;// Curva suave (menos agressiva que pivô)&#10;const unsigned int STEP_DELAY_US_GENTLE   = 1200;&#10;&#10;// Quantidade de meia-etapas por iteração (pode refinar o &quot;ganho&quot; da curva)&#10;const uint8_t STRAIGHT_STEPS_PER_LOOP = 1;&#10;const uint8_t TURN_STEPS_PER_LOOP     = 2;&#10;const uint8_t GENTLE_STEPS_PER_LOOP   = 1;&#10;&#10;// ---------------------- Sequência meia-etapa ------------------------&#10;const uint8_t HALFSTEP_SEQ[8][4] = {&#10;  {1,0,0,0},&#10;  {1,1,0,0},&#10;  {0,1,0,0},&#10;  {0,1,1,0},&#10;  {0,0,1,0},&#10;  {0,0,1,1},&#10;  {0,0,0,1},&#10;  {1,0,0,1}&#10;};&#10;&#10;struct Stepper28BYJ {&#10;  uint8_t pins[4];&#10;  int8_t  idx;        // 0..7&#10;  bool    invert;     // inverte o sentido lógico do motor&#10;};&#10;&#10;// Monte aqui conforme sua fiação&#10;// Invertido globalmente para que goStraight() avance para frente&#10;Stepper28BYJ motorLeft  = { {L_IN1, L_IN2, L_IN3, L_IN4}, 0, true };&#10;Stepper28BYJ motorRight = { {R_IN1, R_IN2, R_IN3, R_IN4}, 0, false };&#10;&#10;// ----------------------------- Funções ------------------------------&#10;void writeCoils(const Stepper28BYJ&amp; m, const uint8_t pat[4]) {&#10;  digitalWrite(m.pins[0], pat[0]);&#10;  digitalWrite(m.pins[1], pat[1]);&#10;  digitalWrite(m.pins[2], pat[2]);&#10;  digitalWrite(m.pins[3], pat[3]);&#10;}&#10;&#10;void stepOnce(Stepper28BYJ &amp;m, int dir /* +1 fwd, -1 bwd */) {&#10;  int realDir = m.invert ? -dir : dir;&#10;  m.idx = (m.idx + (realDir &gt; 0 ? 1 : -1) + 8) % 8;&#10;  writeCoils(m, HALFSTEP_SEQ[m.idx]);&#10;}&#10;&#10;void stepBoth(int dirLeft, int dirRight, uint8_t steps, unsigned int delayUs) {&#10;  for (uint8_t i = 0; i &lt; steps; i++) {&#10;    if (dirLeft  != 0) stepOnce(motorLeft,  dirLeft);&#10;    if (dirRight != 0) stepOnce(motorRight, dirRight);&#10;    delayMicroseconds(delayUs);&#10;  }&#10;}&#10;&#10;// Movimentos de alto nível&#10;void goStraight() {&#10;  stepBoth(+1, +1, STRAIGHT_STEPS_PER_LOOP, STEP_DELAY_US_STRAIGHT);&#10;}&#10;&#10;void turnLeftPivot() {&#10;  // Pivô: esquerda para trás, direita para frente&#10;  stepBoth(-1, +1, TURN_STEPS_PER_LOOP, STEP_DELAY_US_TURN);&#10;}&#10;&#10;void turnRightPivot() {&#10;  // Pivô: esquerda para frente, direita para trás&#10;  stepBoth(+1, -1, TURN_STEPS_PER_LOOP, STEP_DELAY_US_TURN);&#10;}&#10;&#10;void turnLeftGentle() {&#10;  // Curva suave: pivô mais lento (menos passos)&#10;  stepBoth(-1, +1, GENTLE_STEPS_PER_LOOP, STEP_DELAY_US_GENTLE);&#10;}&#10;&#10;void turnRightGentle() {&#10;  // Curva suave: pivô mais lento (menos passos)&#10;  stepBoth(+1, -1, GENTLE_STEPS_PER_LOOP, STEP_DELAY_US_GENTLE);&#10;}&#10;&#10;// ----------------------------- Setup/Loop ---------------------------&#10;enum Mode : uint8_t { MODE_STRAIGHT, MODE_LEFT, MODE_RIGHT, MODE_LEFT_GENTLE, MODE_RIGHT_GENTLE, MODE_IDLE };&#10;Mode lastMode = MODE_STRAIGHT;&#10;&#10;void setup() {&#10;  // Sensores analógicos: apenas INPUT (sem pull-up)&#10;  pinMode(PIN_S_LEFT,   INPUT);&#10;  pinMode(PIN_S_CENTER, INPUT);&#10;  pinMode(PIN_S_RIGHT,  INPUT);&#10;&#10;  for (uint8_t p : motorLeft.pins)  pinMode(p, OUTPUT);&#10;  for (uint8_t p : motorRight.pins) pinMode(p, OUTPUT);&#10;&#10;  // Inicializa bobinas desligadas (opcional manter torque: comente as linhas abaixo)&#10;  digitalWrite(L_IN1, LOW); digitalWrite(L_IN2, LOW);&#10;  digitalWrite(L_IN3, LOW); digitalWrite(L_IN4, LOW);&#10;  digitalWrite(R_IN1, LOW); digitalWrite(R_IN2, LOW);&#10;  digitalWrite(R_IN3, LOW); digitalWrite(R_IN4, LOW);&#10;&#10;#if DEBUG&#10;  Serial.begin(115200);&#10;  delay(300);&#10;  Serial.println(F(&quot;Seguidor de linha - 28BYJ-48 + ULN2003&quot;));&#10;  Serial.print(F(&quot;THRESHOLD=&quot;)); Serial.println(SENSOR_THRESHOLD);&#10;#endif&#10;}&#10;&#10;void loop() {&#10;  // Leituras analógicas 0..1023&#10;  int adcL = analogRead(PIN_S_LEFT);&#10;  int adcC = analogRead(PIN_S_CENTER);&#10;  int adcR = analogRead(PIN_S_RIGHT);&#10;&#10;  // Ativação acima do threshold&#10;  bool L = adcL &gt; SENSOR_THRESHOLD;&#10;  bool C = adcC &gt; SENSOR_THRESHOLD;&#10;  bool R = adcR &gt; SENSOR_THRESHOLD;&#10;&#10;  Mode mode;&#10;&#10;  // Nova regra: se centro + lado ativo -&gt; curva suave para o lado correspondente&#10;  if (C &amp;&amp; L &amp;&amp; !R) {&#10;    mode = MODE_LEFT_GENTLE;&#10;  } else if (C &amp;&amp; R &amp;&amp; !L) {&#10;    mode = MODE_RIGHT_GENTLE;&#10;  } else if (C &amp;&amp; L &amp;&amp; R) {&#10;    // Centro e ambos os lados: trate como reto para estabilizar&#10;    mode = MODE_STRAIGHT;&#10;  } else if (C) {&#10;    mode = MODE_STRAIGHT;&#10;  } else if (L &amp;&amp; !R) {&#10;    mode = MODE_LEFT;&#10;  } else if (R &amp;&amp; !L) {&#10;    mode = MODE_RIGHT;&#10;  } else if (L &amp;&amp; R) {&#10;    // Linha larga / cruzamento: tente seguir reto&#10;    mode = MODE_STRAIGHT;&#10;  } else {&#10;    // Nada detectado: seguir reto&#10;    mode = MODE_STRAIGHT;&#10;  }&#10;&#10;#if DEBUG&#10;  static uint32_t t0 = 0;&#10;  uint32_t now = millis();&#10;  if (now - t0 &gt; 100) {&#10;    t0 = now;&#10;    Serial.print(F(&quot;adc L=&quot;)); Serial.print(adcL);&#10;    Serial.print(F(&quot; C=&quot;)); Serial.print(adcC);&#10;    Serial.print(F(&quot; R=&quot;)); Serial.print(adcR);&#10;    Serial.print(F(&quot; | act L=&quot;)); Serial.print(L);&#10;    Serial.print(F(&quot; C=&quot;)); Serial.print(C);&#10;    Serial.print(F(&quot; R=&quot;)); Serial.print(R);&#10;    Serial.print(F(&quot; | mode=&quot;));&#10;    if (mode == MODE_STRAIGHT) Serial.println(F(&quot;STRAIGHT&quot;));&#10;    else if (mode == MODE_LEFT) Serial.println(F(&quot;LEFT&quot;));&#10;    else if (mode == MODE_RIGHT) Serial.println(F(&quot;RIGHT&quot;));&#10;    else if (mode == MODE_LEFT_GENTLE) Serial.println(F(&quot;LEFT_GENTLE&quot;));&#10;    else if (mode == MODE_RIGHT_GENTLE) Serial.println(F(&quot;RIGHT_GENTLE&quot;));&#10;    else Serial.println(F(&quot;IDLE&quot;));&#10;  }&#10;#endif&#10;&#10;  // Executa movimento curto (não bloqueia por muito tempo) e reavalia&#10;  switch (mode) {&#10;    case MODE_STRAIGHT:      goStraight(); break;&#10;    case MODE_LEFT:          turnLeftPivot(); break;&#10;    case MODE_RIGHT:         turnRightPivot(); break;&#10;    case MODE_LEFT_GENTLE:   turnLeftGentle(); break;&#10;    case MODE_RIGHT_GENTLE:  turnRightGentle(); break;&#10;    default:                 goStraight(); break; // opção segura: avance devagar&#10;  }&#10;&#10;  lastMode = mode;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>